<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rake | Ramón Huidobro]]></title>
  <link href="http://ramonh.github.io/blog/categories/rake/atom.xml" rel="self"/>
  <link href="http://ramonh.github.io/"/>
  <updated>2015-01-10T20:03:32+01:00</updated>
  <id>http://ramonh.github.io/</id>
  <author>
    <name><![CDATA[Ramón Huidobro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Internationalization in RubyMotion Projects]]></title>
    <link href="http://ramonh.github.io/blog/2014/12/03/internationalization-in-rubymotion-projects/"/>
    <updated>2014-12-03T12:46:33+01:00</updated>
    <id>http://ramonh.github.io/blog/2014/12/03/internationalization-in-rubymotion-projects</id>
    <content type="html"><![CDATA[<p>It&rsquo;s not all Bachelor Project for me! One of my contract projects at the moment is to write an OS X app using <a href="http://www.rubymotion.com/">RubyMotion</a>.</p>

<p>One of my goals for this project from the get-go was to make localization really simple. Fortunately, this is really nicely implemented in RubyMotion.</p>

<p>The <a href="https://github.com/rubymotion/sugarcube">SugarCube</a> (MIT license) gem from the RubyMotion community has a localization syntax that allows you to declare a string as localized that is just wonderful. Instead of writing the following:</p>

<pre><code class="objective-c Objective-C">NSLocalizedString(@"String", @"Key")
</code></pre>

<p>You can just write the following:</p>

<pre><code class="ruby Ruby">"String"._
</code></pre>

<p>It&rsquo;s that simple. It works wonders for interpolating strings, too. This is how it looks in Objective-C:</p>

<pre><code class="objective-c Objective-C">NSInteger value = 1
NSLocalizedString(NSStringWithFormat(@"String with value: %ld", value), @"Key")
</code></pre>

<p>&hellip;And this is how it is in RubyMotion-Land:</p>

<pre><code class="ruby Ruby">value = 1
"String #{value}"._
</code></pre>

<p>Meanwhile, you&rsquo;re probably wondering where we need to place these localized strings, as well as how RubyMotion knows what language they belong to. This is also quite simple. In your project&rsquo;s folder, you need a <em>resources</em> folder. This is where your localization files will go. For example, for English, you&rsquo;ll need a folder called <em>en.lproj</em>, or for Spanish they&rsquo;ll go in <em>es.lproj</em>. More language codes can be found in the <a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/LanguageandLocaleIDs/LanguageandLocaleIDs.html">official Apple Docs</a>.</p>

<p>Finally, you need to create a file in the localized folder called <em>Localizable.strings</em>. In it, each line will be formatted like the following example:</p>

<p><em>&ldquo;Hello&rdquo; = &ldquo;Hola&rdquo;;</em></p>

<p>This is nice and all, but here&rsquo;s where it got a little irritating for me: I didn&rsquo;t want to go and copy each line for each localizable file. I therefore wrote a script! A rake task, to be precise. What this task does is it looks at the strings in the English localizable file and copies them into those of the other languages, should these not already contain said string:</p>

<pre><code class="ruby "Generate Localizable Files"">desc "Generate localizable strings"
task :generate_localizable do
  # Go through each English .strings file
  Dir.glob('resources/en.lproj/*.strings') do |strings_file|
    # Go through the other localized folders
    # except for the English one
    Dir.glob('resources/*.lproj') do |folder|
      next if folder == 'resources/en.lproj'
      # Get each string from the English localized file
      File.open(strings_file).each do |line|
        string_regex = line[/(".*"\s*=\s*".*";)/, 1]
        next unless string_regex
        string = string_regex[/(".*")\s*=/, 1]
        puts string
        localized_strings_file = File.join(folder, File.basename(strings_file))
        # Create the new localized strings file if it doesn't exist,
        # and add the string if its non-localized version is not preset
        system("touch #{localized_strings_file}")
        unless File.open(localized_strings_file).read =~ /#{Regexp.quote(string)}\s*=\s*".*";/
          File.open(localized_strings_file, 'a+') { |f| f.write("#{string} = #{string};\n") }
        end
      end
    end
  end
end
</code></pre>

<p>So, if I have a <em>&ldquo;Hello&rdquo; = &ldquo;Hello&rdquo;;</em> line in the English localizable file that&rsquo;s not present in say the Spanish one, the above script will copy that line to the bottom of the Spanish localizable file.</p>

<p><a href="/blog/2015/01/03/internationalization-in-rubymotion-projects-part-2/">Next up</a>, I&rsquo;ll look into a way of looking at the source RubyMotion code and see if I can skip writing the English localizable strings altogether, but this&rsquo;ll do nicely for now!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homesick App - Setting Up a CoffeeScript-written Node.js Project]]></title>
    <link href="http://ramonh.github.io/blog/2014/11/10/homesick-app-setting-up-a-coffeescript-written-node-dot-js-project/"/>
    <updated>2014-11-10T13:38:22+01:00</updated>
    <id>http://ramonh.github.io/blog/2014/11/10/homesick-app-setting-up-a-coffeescript-written-node-dot-js-project</id>
    <content type="html"><![CDATA[<p>This is part of an ongoing series of posts about Homesick, <a href="/blog/2014/11/02/starting-out-with-homesick/">my bachelor project</a>.</p>

<p>The server side is hosted <a href="https://github.com/ramonh/homesick-server">here</a>.</p>

<p>This is a great opportunity for me to learn both Node.js and get acquainted with server-side programming.</p>

<p>Having said that, I realize that using Node.js might be overkill for something that could be solved with a more low-level approach, but I want to learn Node.js, simple as that!</p>

<p>In order to install Node, you can either download an installer from their <a href="http://nodejs.org/">website</a> or install it using your favorite package manager. Myself, I used <a href="http://brew.sh/">Homebrew</a> on OS X with the command <em>$ brew install node</em>.</p>

<p>I also opted for writing CoffeeScript because I find it a lot of fun! If you don&rsquo;t know what CoffeeScript is, it&rsquo;s a language that compiles into JavaScript. Be sure to <a href="http://coffeescript.org/">try it out here!</a>. You can use the NPM (Node Package Manager) that comes bundled with Node to install CoffeeScript using the command <em>$ npm install coffee-script</em>.</p>

<p>As a part of my toolchain, I&rsquo;m personally a huge fan of <a href="https://github.com/jimweirich/rake">rake</a> for setting up tasks.</p>

<p>Here&rsquo;s the tasks I have set up at the moment:</p>

<pre><code class="ruby RakeFile https://github.com/ramonh/homesick-server/blob/master/Rakefile Source">
task :coffee do
  puts 'CoffeeScript compiled!' if system 'coffee -c -o js coffee'
end

task :run =&gt; [:coffee] do
  puts 'Starting server'
  system 'node js/app.js'
end
</code></pre>

<p>Short and sweet. The first tasks just prints &ldquo;CoffeeScript compiled!&rdquo; if the command to compile is successful. The way the <em>coffee</em> command works is it looks at the <em>.coffee</em> files in the coffee folder, and compiles them into the <em>js</em> folder.</p>

<p>What the <em>run</em> task does is it requires the <em>coffee</em> task, that is, it makes sure that the task has been run, and then starts the server with the <em>node</em> command. This takes the compiled <em>app</em> JavaScript file and runs it.</p>

<p>If you&rsquo;d like to get furher into rake, I highly recommend watching the <a href="https://www.youtube.com/watch?v=AFPWDzHWjEY">rake</a> <a href="https://www.youtube.com/watch?v=KaEqZtulOus">talks</a> by rake&rsquo;s creator, the late Jim Weirich. Or really, any talks he gave. They&rsquo;re all wonderful.</p>
]]></content>
  </entry>
  
</feed>
